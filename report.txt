'### LLM_EXTRACTION_PROMPT\n\n```text\nYou are a data processing assistant. Your task is to interpret the provided LaTeX table, which represents a messy Excel spreadsheet containing kindergarten statistics, and convert it into a clean, structured JSON format.\n\n**Table Context:**\n- The data lists kindergartens (유치원) in Daegu, South Korea.\n- **Key entities:** Each kindergarten usually spans **two rows** in the main body.\n  - The **first row** contains the Name (유치원명) and statistical data (dates, counts, areas).\n  - The **second row** contains the Address (소재지) and breakdown data (often labeled \'여\' for Female counts, though in this specific table, the address is in the first column of the second row).\n- **Header Structure:** The headers are multi-row (rows 3-6) and complex.\n  - "인가기준" (Authorized) vs "편성기준" (Organized) columns for Class Counts.\n  - "원아수" (Children Count), "교원" (Teachers), "직원" (Staff).\n  - "교지" (Land Area) and "건물" (Building Area).\n\n**Extraction Rules:**\n1. **Identify Individual Records:**\n   - Detect the pattern where one kindergarten consists of a pair of rows.\n   - Row A: Name, Opening Date, Status, Type, Stats.\n   - Row B: Address (often in the first column or merged under the name).\n   - Ignore "Total" (총계) or "Subtotal" (소계) rows.\n   - Ignore footnote rows.\n\n2. **JSON Structure:**\n   Create a list of objects, where each object represents one kindergarten.\n   Map columns to meaningful English keys. Suggested keys:\n   - `name`: Kindergarten Name (from Row A).\n   - `address`: Address (from Row B).\n   - `opening_date`: Date (YYYY/MM/DD).\n   - `status`: e.g., "Existing", "Closed".\n   - `type`: "Public" (공립) or "Private" (사립).\n   - `class_counts`: Object containing `authorized_total`, `organized_total`, `organized_general`, `organized_special`.\n   - `student_counts`: Object containing `current_total`, `new_entrants`, `graduates`.\n   - `teacher_counts`: Object containing `total_teachers`, `principal`, `vice_principal`, `regular_teachers`.\n   - `staff_counts`: Object containing `admin_staff`, `educational_staff`.\n   - `area`: Object containing `land_area` (m2), `building_area` (m2).\n\n3. **Data Cleaning:**\n   - Handle "NaN" or "-" as 0 for numeric fields or null for text fields.\n   - Merge the address correctly if it spans multiple cells or lines.\n   - Ensure numeric values are numbers, not strings.\n\n4. **Output:**\n   - Return **ONLY** valid JSON.\n   - No markdown formatting like ```json ... ```.\n   - No commentary.\n\n**Input Table:**\n{{Input LaTeX Table}}\n```endoftext\n\n### PYTHON_CODE\n```python\nimport pandas as pd\nimport re\nimport json\n\ndef extract_json_from_excel(EXCEL_PATH, SHEET_NAME=None):\n    """\n    Extracts kindergarten data from an Excel file where each record spans two rows.\n    """\n    try:\n        # Load the workbook\n        if SHEET_NAME:\n            df = pd.read_excel(EXCEL_PATH, sheet_name=SHEET_NAME, header=None)\n        else:\n            df = pd.read_excel(EXCEL_PATH, sheet_name=0, header=None)\n        \n        # The data structure is complex.\n        # Based on the visual inspection:\n        # Row 7 is "Total", Row 8-10 are subtotals/headers for regions.\n        # Actual data starts around row 11.\n        # Structure pattern: \n        # Row N: Name, Date, Status... Stats\n        # Row N+1: Address ... (Gender breakdown - usually empty/irrelevant for the main record structure)\n        \n        records = []\n        \n        # We iterate through rows. We need to find rows where column 0 contains a Kindergarten Name.\n        # A valid kindergarten row usually has a date in Col 2 (index 2) like \'YYYY/MM/DD\'.\n        \n        num_rows = len(df)\n        i = 0\n        \n        while i < num_rows:\n            row = df.iloc[i]\n            \n            # Check for end of valid data (footnotes often start with "주")\n            val_0 = str(row[0]) if pd.notna(row[0]) else ""\n            if val_0.startswith("주") or val_0.startswith("Total") or "총    계" in val_0:\n                i += 1\n                continue\n                \n            # Heuristic to identify a main data row:\n            # Col 2 (Opening Date) should look like a date or valid string, AND Col 0 should not be NaN\n            # Also, filter out Region headers like "달성군" which don\'t have dates in Col 2.\n            \n            # Col indices based on inspection:\n            # 0: Name / Address (next row)\n            # 2: Opening Date\n            # 3: Status\n            # 4: Est. Type\n            # 5: Branch/Single\n            # 14: Organized Class Total (Based on "계" under "편성기준") - checking column alignment\n            # 18: Student Total\n            \n            # Let\'s verify specific columns based on the provided LaTeX structure.\n            # LaTeX header analysis:\n            # Row 3 "유치원명 소재지" is col 0.\n            # Row 3 "최초 개교일" is col 2.\n            # Row 3 "운영 상태" is col 3.\n            \n            col_date_val = str(row[2]) if pd.notna(row[2]) else ""\n            is_date = re.search(r\'\\d{4}/\\d{2}/\\d{2}\', col_date_val)\n            \n            if is_date and pd.notna(row[0]):\n                # This is a primary row. The next row (i+1) contains the address in col 0.\n                \n                # Basic Info\n                name = str(row[0]).strip()\n                opening_date = col_date_val.strip()\n                status = str(row[3]).strip() if pd.notna(row[3]) else None\n                est_type = str(row[4]).strip() if pd.notna(row[4]) else None\n                \n                # Address is in the next row, same column 0\n                address = ""\n                if i + 1 < num_rows:\n                    addr_val = df.iloc[i+1][0]\n                    if pd.notna(addr_val):\n                        address = str(addr_val).strip()\n                \n                # Helper to clean numbers\n                def get_int(val):\n                    if pd.isna(val) or val == \'-\':\n                        return 0\n                    try:\n                        return int(float(val))\n                    except:\n                        return 0\n\n                def get_float(val):\n                    if pd.isna(val) or val == \'-\':\n                        return 0.0\n                    try:\n                        return float(val)\n                    except:\n                        return 0.0\n\n                # Column mapping based on the provided LaTeX headers alignment:\n                # 0: Name\n                # 1: (Unnamed)\n                # 2: Date\n                # 3: Status\n                # 4: Type\n                # 5: Branch/Single\n                # 9: Authorized Class Count (Total)\n                # 10-13: Authorized Breakdown (Skip)\n                # 14: Organized Class Count (Total) -> "계" under "편성기준"\n                # 15: General Class\n                # 16: Special Class\n                # 18: Current Students (Total) -> "원아수"\n                # 19: New Students\n                # 20: Graduates\n                # 21: Total Teachers\n                # 22: Principal\n                # 23: Vice Principal\n                # 24: Regular Teachers\n                # 27: General Staff\n                # 30: Land Area\n                # 31: Building Area\n                \n                # Extracting Stats\n                record = {\n                    "name": name,\n                    "address": address,\n                    "opening_date": opening_date,\n                    "status": status,\n                    "establishment_type": est_type,\n                    "class_counts": {\n                        "authorized_total": get_int(row[9]),\n                        "organized_total": get_int(row[14]),\n                        "organized_general": get_int(row[15]),\n                        "organized_special": get_int(row[16])\n                    },\n                    "student_counts": {\n                        "total": get_int(row[18]),\n                        "new_entrants": get_int(row[19]),\n                        "graduates": get_int(row[20])\n                    },\n                    "teacher_counts": {\n                        "total": get_int(row[21]),\n                        "principal": get_int(row[22]),\n                        "vice_principal": get_int(row[23]),\n                        "regular_teachers": get_int(row[24])\n                    },\n                    "staff_counts": {\n                        "general_staff": get_int(row[27]),\n                        "edu_staff": get_int(row[28]) # Assuming adjacent based on logic\n                    },\n                    "area_m2": {\n                        "land": get_float(row[30]),\n                        "building": get_float(row[31])\n                    }\n                }\n                records.append(record)\n                \n                # Skip the address row\n                i += 2 \n            else:\n                # Just move to next row if not a match\n                i += 1\n                \n        return json.dumps(records, ensure_ascii=False, indent=4)\n\n    except Exception as e:\n        return json.dumps({"error": str(e)}, ensure_ascii=False)\n\nif __name__ == "__main__":\n    # Example usage (dummy path)\n    result = extract_json_from_excel("input.xlsx", SHEET_NAME="유")\n    print(result)\n```'